@init

function synth_reset_controllers() local(i) (
	synthx_pitchbend = 0;
	synthx_pitchbend_ratio = 1;

	i = 0;
	while (i < 128) (
		(i == 7 || i == 10 || (i >= 91 && i <= 95) || (i >= 70 && i <= 79) || i >= 120) ? (
			0; // These don't get reset
		) : (i >= 98 && i <= 101) ? (
			synthx_controllers[i] = 127;
		) : (i != 0 && i != 32) ? (
			synthx_controllers[i] = 0;
		);
		i += 1;
	);
	synthx_controllers[11] = 127;
);

function synth_option_midi_sink(value) (
	synthx_midi_sink = value;
);

function synth_serialize(reset) local(version) (
	version = 3;
	file_var(0, version);
	!reset && version >= 1 ? (
		file_var(0, synthx_midi_sink);
		file_var(0, synthx_legato_mode);
		file_var(0, synthx_legato_portamento_mode);
		file_var(0, synthx_portamento_mode);
		file_var(0, synthx_portamento_seconds);
		file_var(0, synthx_pitchbend_range);
	) : (
		synthx_midi_sink = 0;
		synthx_legato_mode = 0;
		synthx_legato_portamento_mode = 0;
		synthx_portamento_mode = 0;
		synthx_portamento_seconds = 0.03;
		synthx_pitchbend_range = 2;
	);
	!reset && version >= 2 ? (
		file_var(0, synthx_portamento_from_nearest);
	) : (
		synthx_portamento_from_nearest = 0;
	);
	!reset && version >= 3 ? (
		file_var(0, synthx_delay_ratio);
	) : (
		synthx_delay_ratio = 0;
	);
);

function synth_setup(freemem, custom_slots, max_polyphony) local(i) (
	synthx_polyphony = 0;
	synthx_custom_offset = NOTE##;
	synthx_timestep = 1/srate;
	synthx_step = synthx_custom_offset + custom_slots;
	synthx_maxduration = 60*60*24*365*srate; // one year
	synthx_pitchbend = 0;
	synthx_pitchbend_ratio = 1;
	!synthx_pitchbend_range ? synthx_pitchbend_range = 2;
	!synthx_portamento_seconds ? synthx_portamento_seconds = 0.03; // Not enabled, though :)

	synthx_max_active_note = 0;
	freemem = (synthx_controllers = freemem) + 128;
	freemem = (synthx_notestack = freemem) + max_polyphony*synthx_step;

	synth_reset_controllers();
	i = 0;
	while (i < max_polyphony*synthx_step) (
		synthx_notestack[i] = 0;
		i += 1;
	);

	synthx_latest_note = synthx_notestack;
	synthx_latest_note[NOTE#BASE_FREQ] = 440*pow(2, (63 - 69)/12); // Start on note 63
	synthx_latest_note[NOTE#PORTAMENTO_END_SAMPLE] = 0;
	synthx_latest_note[NOTE#BASE_FREQ_SLOPE] = 0;

	/*NOTE: ACTIVE, SAMPLES_FROM_RELEASE, SAMPLES_FROM_ATTACK, SAMPLES_FROM_SUSTAIN_RELEASE, NOTE, BASE_FREQ, VEL, CHANNEL, CUSTOM_INIT*/
	// synth_preblock_each() and synth_block_each() need to have considered all of these
	synthx_custom_offset !== 9 ? (
		synthx.ERROR = uix_error = "synth framework error";
	);

	freemem;
);

function synth_pdc_delay() (
	synthx_supports_latency = 1;
	floor(synthx_delay_ratio*synthx_portamento_seconds*srate);
);

function synth_setup(freemem, custom_slots) (
	synth_setup(freemem, custom_slots, 16);
);

function synth_setup(freemem) (
	synth_setup(freemem, 0);
);

function synth_setup_each(note*) (
	note._synth.index = synthx_polyphony;
	note._synth.mem = synthx_notestack + synthx_step*note._synth.index;
	note = note._synth.mem + synthx_custom_offset;
	synthx_polyphony += 1;
);

function synth_legato(mode/*0: off, 1: legato but still trigger, 2: suppress new notes */, portamento_mode/*0: legato notes only, 1: legato and first notes, 2: releases as well*/) (
	synthx_legato_mode = mode;
	synthx_legato_portamento_mode = portamento_mode;
);
function synth_legato(enabled) (
	synth_legato(enabled, 0);
);

function synth_portamento(mode, seconds) (
	synthx_portamento_mode = mode;
	synthx_portamento_seconds = seconds;
);

function synth_portamento_future_freq_buffer(note) (
	note[NOTE#SAMPLES_FROM_ATTACK] + synthx_delay_samples < note[NOTE#PORTAMENTO_END_SAMPLE] ? (
		(note[NOTE#BASE_FREQ]
			+ min(0, note[NOTE#SAMPLES_FROM_ATTACK] + synthx_delay_samples - note[NOTE#PORTAMENTO_END_SAMPLE])*note[NOTE#BASE_FREQ_SLOPE]
		);
	) : (
		note[NOTE#BASE_FREQ];
	);
);

// Same logic as before - perhaps this should be a mod on top of synth-framework, that just caches things for the @sample block?
function synth_block() local(midi_offset, midi_offset_delayed, midi_msg1, midi_msg23, midi_msg2, midi_msg3, midi_type, midi_channel, i, note, selected_note, base_freq, current_freq, portamento_samples, first_note_of_phrase, previous_note, distance, nearest_distance) (
	synthx_portamento_samples = synthx_portamento_seconds*srate;
	synthx_delay_samples = floor(synthx_delay_ratio*synthx_portamento_samples);
	while (midirecv(midi_offset, midi_msg1, midi_msg23)) (
		!synthx_midi_sink ? (
			midisend(midi_offset, midi_msg1, midi_msg23); // passthrough
		);
		midi_offset_delayed = midi_offset + synthx_delay_samples;
		midi_type = midi_msg1>>4;
		midi_channel = midi_msg1&0x0f;
		midi_msg2 = midi_msg23&$xff; // note / controller
		midi_msg3 = midi_msg23>>8; // velocity / value
		(midi_type == $x9 && midi_msg3 != 0) ? (
			// Note on
			base_freq = 440*pow(2, (midi_msg2 - 69)/12);
			// Is this the first note of a phrase
			first_note_of_phrase = 1;
			first_note_of_phrase_sustained = 1;
			previous_note = synthx_latest_note; // TODO: In case nothing is active, use previous note - ideally we'd have one of these per-channel, but we can't, because there's no guarantee some other channel wouldn't've used it in the meantime.  Perhaps we should cache the latest *frequency* per-channel, because that's what we actually need.
			nearest_distance = 128;
			i = 0;
			// TODO: use loop() instead, and increment by synth_step?
			while (i < synthx_polyphony) (
				note = synthx_notestack + synthx_step*i;
				// This isn't quite accurate - if the sustain pedal is down then it might not register as released, even if the sustain is released later in this block and it would cross the line.  That's probably enough of an edge-case to fudge, though.
				note[NOTE#ACTIVE] && note[NOTE#CHANNEL] == midi_channel && (note[NOTE#SAMPLES_FROM_RELEASE] <= -midi_offset_delayed
					|| (note[NOTE#SAMPLES_FROM_SUSTAIN_RELEASE] <= 0 && synthx_controllers[64] >= 64)
				) ? (
					first_note_of_phrase_sustained = 0;
					note[NOTE#SAMPLES_FROM_RELEASE] <= -midi_offset_delayed ? (
						first_note_of_phrase = 0;
					);
					distance = synthx_portamento_from_nearest ? (
						distance = abs(note[NOTE#NOTE] - midi_msg2);
					) : 0;
					distance < nearest_distance || (distance == nearest_distance && note[NOTE#SAMPLES_FROM_ATTACK] < previous_note[NOTE#SAMPLES_FROM_ATTACK]) ? (
						previous_note = note;
						nearest_distance = distance;
					);
				);
				i += 1;
			);

			synthx_legato_mode ? (
				// Move all unreleased notes to new frequency
				i = 0;
				while (i < synthx_polyphony) (
					note = synthx_notestack + synthx_step*i;
					note[NOTE#ACTIVE] && note[NOTE#CHANNEL] == midi_channel ? (
						note[NOTE#PHRASE_STILL_ACTIVE] ? (
							first_note_of_phrase && synthx_legato_portamento_mode < 2 ? (
								// Any previous phrases are closed
								note[NOTE#PHRASE_STILL_ACTIVE] = 0;
							) : (
								synthx_portamento_mode ? (
									current_freq = synth_portamento_future_freq_buffer(note);
									portamento_samples = synthx_portamento_samples;
									synthx_portamento_mode >= 2 ? portamento_samples *= synthx_controllers[5]/127;
									synthx_portamento_mode == 3 && synthx_controllers[65] < 64 ? portamento_samples = 0;
									portamento_samples += midi_offset;
									note[NOTE#PORTAMENTO_END_SAMPLE] = note[NOTE#SAMPLES_FROM_ATTACK] + portamento_samples;
									note[NOTE#BASE_FREQ_SLOPE] = portamento_samples ? (base_freq - current_freq)/portamento_samples : 0;
								) : (
									note[NOTE#PORTAMENTO_END_SAMPLE] = 0;
									note[NOTE#BASE_FREQ_SLOPE] = 0;
								);
								note[NOTE#BASE_FREQ] = base_freq;
								debug.transition += 1;
								debug.note_from = note[NOTE#NOTE];
								debug.note_to = midi_msg2;
								note[NOTE#NOTE] = midi_msg2;
								synthx_legato_mode < 2 ? ( // We're going to re-trigger a new note, so we close this one
									debug.retrigger += 1;
									note[NOTE#SAMPLES_FROM_RELEASE] = max(note[NOTE#SAMPLES_FROM_RELEASE], -midi_offset_delayed);
									note[NOTE#SAMPLES_FROM_SUSTAIN_RELEASE] = max(note[NOTE#SAMPLES_FROM_SUSTAIN_RELEASE], -midi_offset_delayed);
								) : note[NOTE#SAMPLES_FROM_RELEASE] == -midi_offset_delayed ? (
									debug.force_continue += 1;
									// This note was just released, but it should continue transition to the new pitch instead
									selected_note[NOTE#SAMPLES_FROM_RELEASE] = -synthx_maxduration;
									selected_note[NOTE#SAMPLES_FROM_SUSTAIN_RELEASE] = -synthx_maxduration;
								);
							);
						)
					);
					i += 1;
				);
			);
			(first_note_of_phrase || synthx_legato_mode < 2) ? (
				selected_note = -1;
				// Choose inactive note
				i = 0;
				while (i < synthx_polyphony && selected_note < 0) (
					note = synthx_notestack + synthx_step*i;
					!note[NOTE#ACTIVE] ? (
						selected_note = note;
					);
					i += 1;
				);
				// If we didn't find one, stop a release
				selected_note < 0 ? (
					// Start by selecting random index
					i = floor(rand()*synthx_polyphony);
					selected_note = synthx_notestack + synthx_step*i;
					// Choose note with longest release phase
					i = 0;
					while (i < synthx_polyphony && selected_note < 0) (
						note = synthx_notestack + synthx_step*i;
						note[NOTE#SAMPLES_FROM_SUSTAIN_RELEASE] > selected[NOTE#SAMPLES_FROM_SUSTAIN_RELEASE] ? (
							selected_note = note;
						);
						i += 1;
					);
				);
				// Reset the custom note parameters to 0
				i = synthx_custom_offset;
				while (i < synthx_step) (
					selected_note[i] = 0;
					i += 1;
				);
				// Set up the note parameters
				selected_note[NOTE#ACTIVE] = 1;
				synthx_portamento_mode && (!first_note_of_phrase_sustained || synthx_legato_portamento_mode > 0) ? (
					// This calculation goes first, in case this is the same note we're sweeping from
					portamento_samples = synthx_portamento_samples;
					synthx_portamento_mode >= 2 ? portamento_samples *= synthx_controllers[5]/127;
					synthx_portamento_mode == 3 && synthx_controllers[65] < 64 ? portamento_samples = 0;
					selected_note[NOTE#BASE_FREQ_SLOPE] = portamento_samples ? (base_freq - synth_portamento_future_freq_buffer(previous_note))/portamento_samples : 0;
					selected_note[NOTE#PORTAMENTO_END_SAMPLE] = portamento_samples;
				) : (
					selected_note[NOTE#PORTAMENTO_END_SAMPLE] = 0;
					selected_note[NOTE#BASE_FREQ_SLOPE] = 0;
				);
				selected_note[NOTE#BASE_FREQ] = base_freq;
				selected_note[NOTE#SAMPLES_FROM_ATTACK] = -midi_offset_delayed;
				selected_note[NOTE#SAMPLES_FROM_RELEASE] = -synthx_maxduration;
				selected_note[NOTE#SAMPLES_FROM_SUSTAIN_RELEASE] = -synthx_maxduration;
				selected_note[NOTE#NOTE] = midi_msg2;
				selected_note[NOTE#VEL] = midi_msg3;
				selected_note[NOTE#CHANNEL] = midi_channel;
				selected_note[NOTE#CUSTOM_INIT] = 0;
				selected_note[NOTE#PHRASE_STILL_ACTIVE] = 1;
				synthx_latest_note = selected_note;
			);
		) : (midi_type == $x8 || (midi_type == $x9 && midi_msg3 == 0)) ? (
			// Close open note if there is one
			i = 0;
			while (i < synthx_polyphony) (
				note = synthx_notestack + synthx_step*i;
				note[NOTE#NOTE] == midi_msg2 && note[NOTE#CHANNEL] == midi_channel ? (
					note[NOTE#SAMPLES_FROM_RELEASE] = max(note[NOTE#SAMPLES_FROM_RELEASE], -midi_offset_delayed);
					note[NOTE#SAMPLES_FROM_SUSTAIN_RELEASE] = max(note[NOTE#SAMPLES_FROM_SUSTAIN_RELEASE], -midi_offset_delayed);
				);
				i += 1;
			);
		) : (midi_type == 11) ? (
			// Controller
			midi_msg2 == 121 ? (
				synth_reset_controllers();
			) : midi_msg2 == 123 ? (
				// stop all notes (with release)
				i = 0;
				while (i < synthx_polyphony) (
					note = synthx_notestack + synthx_step*i;
					note[NOTE#SAMPLES_FROM_RELEASE] = max(note[NOTE#SAMPLES_FROM_RELEASE], 0);
					note[NOTE#SAMPLES_FROM_SUSTAIN_RELEASE] = max(note[NOTE#SAMPLES_FROM_SUSTAIN_RELEASE], 0);
					i += 1;
				);
			) : midi_msg2 == 120 ? (
				// stop all notes (no release)
				i = 0;
				while (i < synthx_polyphony) (
					note = synthx_notestack + synthx_step*i;
					note[NOTE#ACTIVE] = 0;
					i += 1;
				);
			) : (
				synthx_controllers[midi_msg2] = midi_msg3;
			);
		) : (midi_type == 14) ? (
			synthx_pitchbend = (midi_msg3*128 + midi_msg2) - 8192;
			synthx_pitchbend_ratio = pow(2, synthx_pitchbend_range/12*synthx_pitchbend/8192);
		);
	);
	synthx_max_active_note = -1;
	i = 0;
	note = synthx_notestack;
	while (i < synthx_polyphony) (
		note[NOTE#ACTIVE] ? (
			synthx_max_active_note = i;
		);
		i += 1;
		note += synthx_step;
	);
	synthx_max_active_note + 1;
);

function synth_preblock_each(note*) local() (
	// We don't need to set _mem[NOTE#ACTIVE], because synth_stop() does that
	note._synth.ACTIVE ? (
		note._synth.mem[NOTE#SAMPLES_FROM_RELEASE] = note._synth.SAMPLES_FROM_RELEASE;
		note._synth.mem[NOTE#SAMPLES_FROM_ATTACK] = note._synth.SAMPLES_FROM_ATTACK;
		note._synth.mem[NOTE#SAMPLES_FROM_SUSTAIN_RELEASE] = note._synth.SAMPLES_FROM_SUSTAIN_RELEASE;
		note._synth.mem[NOTE#CUSTOM_INIT] = note._synth.CUSTOM_INIT;
	);

	/* Not ever changed in @sample */
	//note._synth.mem[NOTE#NOTE] = note._synth.NOTE;
	//note._synth.mem[NOTE#BASE_FREQ] = note._synth.BASE_FREQ;
	//note._synth.mem[NOTE#BASE_FREQ_SLOPE] = note._synth.BASE_FREQ_SLOPE;
	//note._synth.mem[NOTE#PORTAMENTO_END_SAMPLE] = note._synth.PORTAMENTO_END_SAMPLE;
	//note._synth.mem[NOTE#VEL] = note._synth.VEL;
	//note._synth.mem[NOTE#CHANNEL] = note._synth.CHANNEL;

	// TODO: does synth_continue(note) make this faster or slower here?
	//synth_continue(note);
	1;
);

function synth_block_each(note*) local() (
	(note._synth.ACTIVE = note._synth.mem[NOTE#ACTIVE]) ? (
		note._synth.SAMPLES_FROM_RELEASE = note._synth.mem[NOTE#SAMPLES_FROM_RELEASE];
		note._synth.SAMPLES_FROM_ATTACK = note._synth.mem[NOTE#SAMPLES_FROM_ATTACK];
		note._synth.SAMPLES_FROM_SUSTAIN_RELEASE = note._synth.mem[NOTE#SAMPLES_FROM_SUSTAIN_RELEASE];
		note._synth.NOTE = note._synth.mem[NOTE#NOTE];
		note._synth.BASE_FREQ = note._synth.mem[NOTE#BASE_FREQ];
		note._synth.BASE_FREQ_SLOPE = note._synth.mem[NOTE#BASE_FREQ_SLOPE];
		note._synth.PORTAMENTO_END_SAMPLE = note._synth.mem[NOTE#PORTAMENTO_END_SAMPLE];
		note._synth.VEL = note._synth.mem[NOTE#VEL];
		note._synth.CHANNEL = note._synth.mem[NOTE#CHANNEL];
		note._synth.CUSTOM_INIT = note._synth.mem[NOTE#CUSTOM_INIT];
	);
	//synth_continue(note);
	1;
);

function synth_on(note*) (
	note._synth.ACTIVE && note._synth.SAMPLES_FROM_ATTACK >= 0;
);

function synth_sample() (
	synthx_max_active_note >= 0;
);

function synth_sample_each(note*) (
	note._synth.ACTIVE ? (
		note._synth.SAMPLES_FROM_ATTACK += 1;
		note._synth.SAMPLES_FROM_RELEASE += 1;
		note._synth.SAMPLES_FROM_RELEASE < 0 || synthx_controllers[64] < 64 ? (
			note._synth.SAMPLES_FROM_SUSTAIN_RELEASE += 1;
		);
		note._synth.SAMPLES_FROM_ATTACK >= 0
	) : 0;
);

function synth_continue(note*) (
	note._synth.index < synthx_max_active_note;
);

function synth_needs_init(note*) (
	note._synth.CUSTOM_INIT ? (
		0;
	) : (
		note._synth.CUSTOM_INIT = 1;
	);
);

function synth_stop(note*) (
	// This is the only one where we update the memory at the time, because it's called so rarely
	note._synth.ACTIVE = note._synth.mem[NOTE#ACTIVE] = 0;
);

function synth_midinote(note*) (
	note._synth.NOTE;
);

function synth_portamento_freq(note*) (
	note._synth.SAMPLES_FROM_ATTACK < note._synth.PORTAMENTO_END_SAMPLE ? (
		(note._synth.BASE_FREQ
			+ (note._synth.SAMPLES_FROM_ATTACK - note._synth.PORTAMENTO_END_SAMPLE)*note._synth.BASE_FREQ_SLOPE
		);
	) : (
		note._synth.BASE_FREQ;
	);
);

function synth_freq(note*) (
	note._synth.SAMPLES_FROM_ATTACK < note._synth.PORTAMENTO_END_SAMPLE ? (
		(note._synth.BASE_FREQ
			+ (note._synth.SAMPLES_FROM_ATTACK - note._synth.PORTAMENTO_END_SAMPLE)*note._synth.BASE_FREQ_SLOPE
		)*synthx_pitchbend_ratio;
	) : (
		note._synth.BASE_FREQ*synthx_pitchbend_ratio;
	);
);

function synth_base_freq(note*) (
	note._synth.BASE_FREQ;
);

function synth_velocity(note*) (
	note._synth.VEL;
);

function synth_channel(note*) (
	note._synth.CHANNEL;
);

function synth_pitchbend() (
	synthx_pitchbend;
);

function synth_pitchbend_semitones() (
	synthx_pitchbend/8192*synthx_pitchbend_range;
);

function synth_attack(note*) (
	note._synth.SAMPLES_FROM_ATTACK;
);

function synth_attack_seconds(note*) (
	synth_attack(note)*synthx_timestep;
);

function synth_release(note*) (
	note._synth.SAMPLES_FROM_RELEASE;
);

function synth_sustain_release(note*) (
	note._synth.SAMPLES_FROM_SUSTAIN_RELEASE;
);

function synth_release_seconds(note*) (
	synth_release(note)*synthx_timestep;
);

function synth_sustain_release_seconds(note) (
	synth_sustain_release(note)*synthx_timestep;
);

function synth_controller(number) (
	synthx_controllers[number];
);
