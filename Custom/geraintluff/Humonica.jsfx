/* Generated by: JSFX Pre-Processor (https://github.com/geraintluff/jsfx-preprocessor) */
desc:Humonica - Synth & Harmoniser (by Geraint Luff)

in_pin:Left
in_pin:Right
out_pin:Left
out_pin:Right

slider1:attack_ms=5<0,1000,1>-Env. Attack (ms)
slider2:release_ms=10<1,2000,1>-Env. Release (ms)
slider3:window_ms=30<20,150,1>-Window (ms)
slider4:crossover_ratio=1.25<1,10,0.25>-Window crossover factor
slider5:latency_switch=1<0,1,1{live,compensated}>-Latency compensation
slider6:stereo_switch=0<0,1,1{2ch,1ch}>-Stereo
slider7:timbre_shift_semitones=0<-12,12,0.1>-Timbre shift (semitones)
slider8:timbre_shift_tracking=0<-1,1,0.01>-Timbre key-tracking (relative to middle C)
slider9:lowpass_freq_khz=8<1,20,0.1>-Lowpass (kHz)
slider10:vibrato_tracking=0<0,1,0.01>-Vibrato tracking
slider11:tonality_limit=0<0,0.5,0.01>-Tonality limit
slider12:lr_detune_cents=3<0,100,1>-L/R detune
slider13:vib_mode=1<0,1,1{tracking,LFO}>-Vib mode
slider14:vib_lfo_scale_cents=5<0,100,1>-Vib LFO cents
slider15:vib_lfo_hz=4.7<0.5,10,.01>-Vib LFO Hz
slider16:vib_lfo_attack_ms=350<1,2000,1>-Vib LFO attack (ms)
slider17:stereo_width=0.5<0,1,0>-Stereo Width
slider18:timbre_shift_sustain_semitones=0<-48,12>-Timbre shift sustain (semitones)
slider19:timbre_shift_decay_ms=150<1,2000>-Timbre shift decay (ms)
slider20:timbre_shift_velocity_semitones=0<-12,12>-Timbre shift velocity (semitones)
slider21:env_sustain=1<0,1>-Env. Sustain
slider22:env_decay_ms=300<1,2000,1>-Env. Decay (ms)
slider23:waveform_mode=1<0,1,1{fixed,analysis}>-Waveform mode
slider24:volume_target_db=-12<-24,0,1>-Target volume (dB)
slider25:volume_max_gain_db=24<0,48,1>-Max volume boost (dB)
slider26:detuning_random_amount=0<0,0.1>-Growl
slider27:detuning_random_halving=0<0,0.5>-Grit
slider28:timbre_shift_decay_velocity_log2=0<-4,4>-Timbre shift decay velocity-sensitivity
//slider40:oversampling_factor_log2=0<0,3,1{x1,x2,x4,x8}>Oversampling

import ui-lib.jsfx-inc
import synth-framework-obj.jsfx-inc
import synth-framework-obj-ui.jsfx-inc
import filter-utils.jsfx-inc
import smoother.jsfx-inc
import graph-utils.jsfx-inc

@init
!gfx_ext_retina ? gfx_ext_retina = 1;

// TODO: why do we need this?
// On init (playback), the UI flashes an "unknown screen" error briefly
// The @gfx code runs in a different thread, so this could be a race condition interacting with the shuffling of ui_setup() around.
// We already had to introduce a minimum for srate because otherwise certain important lengths == 0, which caused infinite loops.
!srate ? srate = max(last_srate, 8000);
last_srate = srate;

FFT_MAX_SIZE = 32768;
MAX_WINDOW_MS = 200;
MAX_WINDOW_SAMPLES = srate*MAX_WINDOW_MS*0.001;

freemem = 0;
freemem = (fft_block = freemem) + FFT_MAX_SIZE*2;

// This has to be in a fixed position, or it gets overwritten when we change samplerate
SPECTRUM_MAX_N = 1000;
!spectrum_low_freq ? (
	spectrum_low_freq = 20;
	spectrum_high_freq = 20000;
	spectrum_min_db = -60;
);
freemem = (spectrum_db = freemem) + SPECTRUM_MAX_N;

kernel_length = MAX_WINDOW_SAMPLES;
freemem = (kernelA0 = freemem) + kernel_length;
freemem = (kernelA1_read = kernelA1 = freemem) + kernel_length;
freemem = (kernelB0 = freemem) + kernel_length;
freemem = (kernelB1_read = kernelB1 = freemem) + kernel_length;
input_buffer_length = MAX_WINDOW_SAMPLES + 10;
freemem = (input_buffer0 = freemem) + input_buffer_length;
freemem = (input_buffer1 = freemem) + input_buffer_length;

// Wipe all buffers
i = kernelA0;
while (i < freemem) (
	i[] = 0;
	i += 1;
);

function default_spectrum_db(freq, mode) (
	mode == 2 ? (
		freq < 1500 ? (
			-20 - 12*max(0, log(freq/800))
			+ 6*exp(-pow((freq - 400)/150, 2))
			+ 4*exp(-pow((freq - 1200)/400, 2))
			+ 4*exp(-pow((freq - 1400)/100, 2))
			+ 4*exp(-pow((freq - 800)/130, 2))
		) : spectrum_min_db;
	) : (
		-24 - 24*max(0, log(freq/1000))
		+ 9*exp(-pow((freq - 2000)/300, 2))
		+ 9*exp(-pow((freq - 2800)/200, 2))
		+ 6*exp(-pow((freq - 800)/500, 2));
	);
);

function reset_spectrum(N, mode) local(i, freq) (
	spectrum_N = min(SPECTRUM_MAX_N, N);
	i = 0;
	while (i < spectrum_N) (
		freq = spectrum_low_freq*exp(log(spectrum_high_freq/spectrum_low_freq)*i/spectrum_N);
		spectrum_db[i] = default_spectrum_db(freq, mode);
		i += 1;
	);
	spectrum_kernel_is_up_to_date = 0;
);
function reset_spectrum(N) (
	reset_spectrum(N, 1);
);
!spectrum_N ? (
	reset_spectrum(300);
);
spectrum_kernel_is_up_to_date = 0;

freemem = ui_setup(freemem);
freemem = synth_setup(freemem);
synth_setup_each(synth1);
synth_setup_each(synth2);
synth_setup_each(synth3);
synth_setup_each(synth4);
synth_setup_each(synth5);
synth_setup_each(synth6);
synth_setup_each(synth7);
synth_setup_each(synth8);
synth_setup_each(synth9);
synth_setup_each(synth10);
synth_setup_each(synth11);
synth_setup_each(synth12);
synth_setup_each(synth13);
synth_setup_each(synth14);
synth_setup_each(synth15);
synth_setup_each(synth16);

freemem = filter_buffer_init(filter_left = freemem);
freemem = filter_buffer_init(filter_right = freemem);

freemem = filter_buffer_init(freq_factor_filter = freemem);
filter_buffer_highpass(freq_factor_filter, 3, 1.5);

smoother_init(timbre_shift_semitones);
smoother_init(stereo_width);

@slider

function check_for_old_presets() (
	// Catch presets from before v2 (we didn't have preset_version before this)
	// We deliberately changed how the crossover slider is stored so that we could do this
	crossover_ratio >= 40 ? (
		// Older versions stored a "crossover_percent" value, so we convert
		crossover_ratio = 50/(100 - crossover_ratio);

		// Emulate pre-v2 behaviour
		lr_detune_cents = 0; // Detuning didn't exist
		stereo_width = 1; // Didn't have stereo width control
		vibrato_tracking || tonality_limit ? (
			vib_mode = 0; // tracking mode used to be the only option
		) : (
			vib_lfo_scale_cents = 0; // stay in LFO mode, but have no amplitude
		);
	);
);

check_for_old_presets();

@block

smoothing = smoother_block(timbre_shift_semitones)
	+ smoother_block(stereo_width);

crossover_percent = 100 - 50/crossover_ratio;

attack_samples = srate*attack_ms*0.001;
release_samples = srate*release_ms*0.001;
window_samples = max(srate, 8000)*window_ms*0.001;
env_decay_samples = srate*env_decay_ms*0.001;
env_decay_factor = exp(-1/env_decay_samples);
interval_samples = window_samples*(1 - crossover_percent/100);
old_fft_size = fft_size;
waveform_mode ? (
	oversampling_factor = 1;
	fft_size = pow(2, ceil(log(window_samples*1.5)/log(2)))*oversampling_factor;
) : (
	// TODO: have this as a setting, instead of a constant
	// Fixed 4x oversampling
	waveform_samples = max(srate, 8000)*0.05;
	fft_size = pow(2, ceil(log(waveform_samples*1.5)/log(2)));
	oversampling_factor = 1;
	while (fft_size < 32768 && oversampling_factor < 4 && srate*oversampling_factor < 120000) (
		fft_size *= 2;
		oversampling_factor *= 2;
	);
);
old_fft_size !== fft_size ? (
	i = 0;
	while (i < fft_size*0.5) (
		fft_block[i*2] = 0;
		fft_block[i*2 + 1] = 0;
		i += 1;
	);
	while (i < fft_size) (
		fft_block[i*2] = 1;
		fft_block[i*2 + 1] = 0;
		i += 1;
	);
	fft_permute(fft_block, fft_size);
	high_half_bitmask = $xffff;
	i = 0;
	while (i < fft_size) (
		fft_block[i*2] ? (
			high_half_bitmask &= i;
		);
		i += 1;
	);
	!high_half_bitmask ? ui_error("Something has changed with the FFT implementation\n\nThis is a BIG PROBLEM.\n\nPlease contact luffgd@gmail.com to get it fixed");
	spectrum_kernel_is_up_to_date = 0;
);

action_reset_spectrum > 0 ? (
	reset_spectrum(spectrum_N, action_reset_spectrum);
	action_reset_spectrum = 0;
	uix_undo_point();
);

function copy_spectrum_from_input(buffer0, buffer1) local(i, ratio, window_value, real, imag, mag2, low_freq, high_freq, low_index, high_index, sum, j, db, max_db) (
	i = 0;
	// Fill with (stereo) input
	while (i < fft_size) (
		ratio = i/window_samples;
		window_value = 0.5 - 0.5*cos(ratio*2*$pi);
		index = input_index - i;
		while (index < 0) (
			index += input_buffer_length;
		);
		fft_block[i*2] = buffer0[index]*window_value;
		fft_block[i*2 + 1] = buffer1[index]*window_value;
		i += 1;
	);

	fft(fft_block, fft_size);
	fft_permute(fft_block, fft_size);

	i = 0;
	while (i < fft_size) (
		real = fft_block[i*2];
		imag = fft_block[i*2 + 1];
		mag2 = real*real + imag*imag;
		fft_block[i] = mag2;
		i += 1;
	);

	i = 0;
	while (i < spectrum_N) (
		low_freq = spectrum_low_freq*exp(log(spectrum_high_freq/spectrum_low_freq)*(i - 0.5)/spectrum_N);
		high_freq = spectrum_low_freq*exp(log(spectrum_high_freq/spectrum_low_freq)*(i + 0.5)/spectrum_N);
		low_index = floor(fft_size*(low_freq/srate));
		high_index = ceil(fft_size*(high_freq/srate));
		low_index = max(1, min(fft_size*0.5, low_index));
		high_index = max(1, min(fft_size*0.5, high_index));

		mag2 = 0;
		j = low_index;
		while (j <= high_index) (
			mag2 += fft_buffer[j] + fft_buffer[fft_size - j];
			j += 1;
		);
		high_index > low_index ? (mag2 /= (high_index - low_index)) : mag2 = 0;
		db = 10*log(max(mag2, 0.000000000001))/log(10);
		spectrum_db[i] = db;
		i += 1;
	);
	max_db = 0;
	i = 0;
	while (i < spectrum_N) (
		max_db = max(max_db, spectrum_db[i]);
		i += 1;
	);

	i = 0;
	while (i < spectrum_N) (
		spectrum_db[i] = max(spectrum_db[i] - max_db, spectrum_min_db);
		i += 1;
	);

	spectrum_kernel_is_up_to_date = 0;
);
action_sample_audio ? (
	action_sample_audio = 0;
	copy_spectrum_from_input(input_buffer0, input_buffer1);
	uix_undo_point();
);

abs(timbre_shift_semitones) > 0.1 ? (
	timbre_shift_factor = pow(2, smoother_value(timbre_shift_semitones)/12);
) : (
	timbre_shift_factor = 1;
);

input_buffer0[input_index] = 0;
input_buffer1[input_index] = 0;

// synth framework boilerplate
synth_preblock_each(synth1)
&& synth_preblock_each(synth2)
&& synth_preblock_each(synth3)
&& synth_preblock_each(synth4)
&& synth_preblock_each(synth5)
&& synth_preblock_each(synth6)
&& synth_preblock_each(synth7)
&& synth_preblock_each(synth8)
&& synth_preblock_each(synth9)
&& synth_preblock_each(synth10)
&& synth_preblock_each(synth11)
&& synth_preblock_each(synth12)
&& synth_preblock_each(synth13)
&& synth_preblock_each(synth14)
&& synth_preblock_each(synth15)
&& synth_preblock_each(synth16);
any_notes_active = synth_block();
synth_block_each(synth1)
&& synth_block_each(synth2)
&& synth_block_each(synth3)
&& synth_block_each(synth4)
&& synth_block_each(synth5)
&& synth_block_each(synth6)
&& synth_block_each(synth7)
&& synth_block_each(synth8)
&& synth_block_each(synth9)
&& synth_block_each(synth10)
&& synth_block_each(synth11)
&& synth_block_each(synth12)
&& synth_block_each(synth13)
&& synth_block_each(synth14)
&& synth_block_each(synth15)
&& synth_block_each(synth16);

latency_samples = (waveform_mode && latency_switch) ? window_samples*0.5 + interval_samples : 0;

pdc_bot_ch = 0;
pdc_top_ch = 2;
pdc_delay = latency_samples;

function note_block(note*) (
	timbre_semitones = timbre_shift_tracking*(synth_midinote(note) - 60) + timbre_shift_velocity_semitones*(synth_velocity(note) - 64)/64;
	note.TIMBRE_FACTOR = pow(2, timbre_semitones/12)*oversampling_factor;
	synth_continue(note);
);
note_block(synth1)
&& note_block(synth2)
&& note_block(synth3)
&& note_block(synth4)
&& note_block(synth5)
&& note_block(synth6)
&& note_block(synth7)
&& note_block(synth8)
&& note_block(synth9)
&& note_block(synth10)
&& note_block(synth11)
&& note_block(synth12)
&& note_block(synth13)
&& note_block(synth14)
&& note_block(synth15)
&& note_block(synth16);

lowpass_freq = lowpass_freq_khz*1000;
filter_buffer_lowpass(filter_left, lowpass_freq, 1.4);
filter_buffer_lowpass(filter_right, lowpass_freq, 1.4);

freq_slew = 1/(interval_samples + 0.03*srate);
!freq_factor ? freq_factor = 1;

tonality_smooth_seconds = 0.05;
tonality_smooth_slew = 1/(tonality_smooth_seconds*srate);

wavelength_average_seconds = 0.3;
wavelength_average_slew = 1/(wavelength_average_seconds*srate);
//wavelength_average = target_wavelength = 0;

lr_detune_factor = pow(2, lr_detune_cents/1200/2);
vib_lfo_scale_factor = pow(2, vib_lfo_scale_cents/1200) - 1;
vib_lfo_attack_samples = srate*vib_lfo_attack_ms/1000;
vib_lfo_wavelength_samples = srate/vib_lfo_hz;

half_kernel_length = kernel_length >> 1;
half_kernel_length_minus_one = half_kernel_length - 1;

@sample

smoothing ? (
	smoother_sample(timbre_shift_semitones);
	smoother_sample(stereo_width);

	abs(timbre_shift_semitones) > 0.1 ? (
		timbre_shift_factor = pow(2, smoother_value(timbre_shift_semitones)/12);
	) : (
		timbre_shift_factor = 1;
	);
);

function smooth_fade(phase) (
	phase*phase*(3 - 2*phase);
);

input_buffer0[input_index] = spl0;
input_buffer1[input_index] = spl1;
input_index += 1;
input_index >= input_buffer_length ? (
	input_index = 0;
);

function fill_kernel_from_input(kernel, buffer, secondary_buffer) local(peak, norm_factor, sum1, sum2, max_abs, i, i2, ratio, window_value, scaling_factor, index, real, imag, mag, mag2, mag2sum, max_abs) (
	i = 0;
	max_abs = 0;
	// Fill with input
	while (i < window_samples && i < fft_size) (
		ratio = i/window_samples;
		window_value = 0.5 - 0.5*cos(ratio*2*$pi);
		index = input_index - i;
		while (index < 0) (
			index += input_buffer_length;
		);
		fft_block[i*2] = buffer[index]*window_value;
		max_abs = max(max_abs, abs(buffer[index]));
		secondary_buffer >= 0 ? (
			fft_block[i*2 + 1] = secondary_buffer[index]*window_value;
			max_abs = max(max_abs, abs(secondary_buffer[index]));
		) : (
			fft_block[i*2 + 1] = 0;
		);
		i += 1;
	);
	max_abs > 0.00000001 ? (
		while (i < fft_size) (
			fft_block[i*2] = 0;
			fft_block[i*2 + 1] = 0;
			i += 1;
		);

		// Zero-phase
		fft(fft_block, fft_size);
		fft_permute(fft_block, fft_size);
		fft_block[0] = fft_block[1] = 0;
		i = 1;

		mag2sum = 0;
		while (i < fft_size) (
			real = fft_block[i*2];
			imag = fft_block[i*2 + 1];
			mag2 = real*real + imag*imag;
			mag = sqrt(mag2);
			mag2sum += mag2;

			fft_block[i*2] = 0;
			fft_block[i*2 + 1] = mag/fft_size;
			i < fft_size/2 ? fft_block[i*2 + 1] *= -1;

			i += 1;
		);
		fft_ipermute(fft_block, fft_size);
		ifft(fft_block, fft_size);

		max_abs = 0;
		i = 0;
		while (i < fft_size) (
			max_abs = max(max_abs, abs(fft_block[i]));
			i += 2;
		);

		// Zero out kernel
		memset(kernel, 0, kernel_length);

		// Place result in kernel
		i = 0;
		scaling_factor = (secondary_buffer >= 0) ? sqrt(0.5) : 1;
		mag = sqrt(mag2sum)/fft_size + max_abs;
		scaling_factor *= min(pow(10, volume_max_gain_db/20), 2*pow(10, volume_target_db/20)/mag);
		while (i < fft_size*0.5 && i < half_kernel_length) (
			kernel[i] = fft_block[i*2]*scaling_factor;
			i += 1;
		);
		i = 1;
		while (i < fft_size*0.5 && i < half_kernel_length) (
			i2 = kernel_length - i;
			kernel[i2] = fft_block[(fft_size - i)*2]*scaling_factor;
			i += 1;
		);
	) : (
		// Zero out kernel
		memset(kernel, 0, kernel_length);
	);
);

function fill_kernel_from_spectrum(kernel) local(i, db, mag, mag2, scaling, freq, weight) (
	i = 0;
	mag2 = 0;
	while (i < fft_size) (
		freq = min(i, fft_size - i)/fft_size*srate*oversampling_factor;
		freq_index = log(freq/spectrum_low_freq)/log(spectrum_high_freq/spectrum_low_freq)*spectrum_N;
		freq_index < 0 || freq_index > spectrum_N - 1 ? (
			mag = 0;
		) : (
			db = spectrum_db[floor(freq_index + 0.5)];
			mag = (db <= spectrum_min_db) ? 0 : pow(10, db/20);
		);
		weight = (freq < 200) ? freq/200 : freq > 4000 ? min(3, freq/4000) : 1;
		mag2 += mag*mag*weight;

		fft_block[i*2] = 0;
		fft_block[i*2 + 1] = mag;
		i < fft_size/2 ? fft_block[i*2 + 1] *= -1;

		i += 1;
	);
	fft_ipermute(fft_block, fft_size);
	ifft(fft_block, fft_size);

	// Zero out kernel
	memset(kernel, 0, kernel_length);

	scaling = mag2 ? 0.125*pow(10, volume_target_db/20)/sqrt(mag2) : 0;

	// Place result in kernel
	i = 0;
	while (i < fft_size*0.5 && i < half_kernel_length) (
		kernel[i] = fft_block[i*2]*scaling;
		i += 1;
	);
	i = 1;
	while (i < fft_size*0.5 && i < half_kernel_length) (
		i2 = kernel_length - i;
		kernel[i2] = fft_block[(fft_size - i)*2]*scaling;
		i += 1;
	);
);

interval_index += 1;
any_notes_active ? (
	waveform_mode ? (
		interval_index >= interval_samples ? (
			instant_crossfade = interval_index >= interval_samples*1.2;
			interval_index = 0;

			// Swap kernels
			tmp = kernelA0;
			kernelA0 = kernelB0;
			kernelB0 = tmp;
			tmp = kernelA1;
			kernelA1 = kernelB1;
			kernelB1 = tmp;
			tmp = kernelA1_read;
			kernelA1_read = kernelB1_read;
			kernelB1_read = tmp;

			stereo_switch ? (
				fill_kernel_from_input(kernelB0, input_buffer0, -1);
				fill_kernel_from_input(kernelB1, input_buffer1, -1);
				kernelB1_read = kernelB1;
			) : (
				fill_kernel_from_input(kernelB0, input_buffer0, input_buffer1);
				kernelB1_read = kernelB0;
			);
			instant_crossfade ? (
				memcpy(kernelA0, kernelB0, kernel_length);
				stereo_switch ? (
					memcpy(kernelA1, kernelB1, kernel_length);
				);
			);

			vib_mode == 0 && (vibrato_tracking || tonality_limit) ? (
				lowest_value = 0;
				highest_value = 0;
				highest_index = 0;
				i = 0;
				while (i < kernel_length/2) (
					value = (kernelB0[i] + kernelB1_read[i]);
					value < lowest_value ? (
						highest_value = highest_index = 0;
						lowest_value = value;
					) : value > highest_value ? (
						highest_value = value;
						highest_index = i;
					);
					i += 1;
				);
				highest_index ? (
					target_wavelength = highest_index;
				);

				tonality_limit ? (
					first_value = (kernelB0[0] + kernelB1_read[0]);
					tonality = first_value ? highest_value/first_value : 0;
					factor = max(0, min(1, (tonality - tonality_limit)/tonality_limit));
					tonality_factor += (factor - tonality_factor)*tonality_smooth_slew*interval_samples;

					i = 0;
					while (i < kernel_length) (
						kernelB0[i] *= tonality_factor;
						kernelB1_read[i] *= tonality_factor;
						i += 1;
					);
				);
			);
		);
	) : spectrum_kernel_is_up_to_date < 2 ? (
		// Spectrum-based
		interval_index >= interval_samples ? (
			spectrum_kernel_is_up_to_date += 1;

			// Swap kernels
			tmp = kernelA0;
			kernelA0 = kernelB0;
			kernelB0 = tmp;
			tmp = kernelA1;
			kernelA1 = kernelB1;
			kernelB1 = tmp;
			tmp = kernelA1_read;
			kernelA1_read = kernelB1_read;
			kernelB1_read = tmp;

			fill_kernel_from_spectrum(kernelB0);
			kernelB1_read = kernelB0;
			interval_index = 0;
		);
	);
	kernel_crossfade = interval_index < interval_samples ? smooth_fade(interval_index/interval_samples) : 1;
);

vibrato_tracking ? (
	low_factor = 0.98;
	high_factor = 1/low_factor;
	wavelength_average += (target_wavelength - wavelength_average)*wavelength_average_slew;
	wavelength_average = max(target_wavelength*low_factor, min(target_wavelength*high_factor, wavelength_average));
	target_ratio = target_wavelength/wavelength_average;
	//target_ratio = max(low_factor, min(high_factor, target_ratio));
	target_ratio = 1 + filter_buffer_sample(freq_factor_filter, target_ratio - 1);
	target_ratio = max(low_factor, min(high_factor, target_ratio));

	freq_factor += (target_ratio - freq_factor)*freq_slew;
) : (
	freq_factor = 1;
);

spl0 = spl1 = 0;

function interp_sample(index, wavelength, kernelA, kernelB) local(result, phase, indexA, indexB, floor_indexA, floor_indexB, floor_indexA2, floor_indexB2, ratioA, ratioB, valueA, valueB) (
	phase = smooth_fade(index/wavelength);

	indexA = min(index*timbre_factor, half_kernel_length_minus_one);
	indexB = max(half_kernel_length, kernel_length + (index - wavelength)*timbre_factor);
	floor_indexA = floor(indexA);
	floor_indexB = floor(indexB);
	floor_indexA2 = floor_indexA + 1;
	floor_indexB2 = floor_indexB + 1;
	floor_indexB2 >= kernel_length ? floor_indexB2 = 0;
	ratioA = indexA - floor_indexA;
	ratioB = indexB - floor_indexB;

	valueA = kernelA[floor_indexA];
	valueA += (kernelA[floor_indexA2] - valueA)*ratioA;
	valueB = kernelA[floor_indexB];
	valueB += (kernelA[floor_indexB2] - valueB)*ratioB;
	result = valueA + (valueB - valueA)*phase;

	valueA = kernelB[floor_indexA];
	valueA += (kernelB[floor_indexA2] - valueA)*ratioA;
	valueB = kernelB[floor_indexB];
	valueB += (kernelB[floor_indexB2] - valueB)*ratioB;
	value = valueA + (valueB - valueA)*phase;
	result + (value - result)*kernel_crossfade;
);

function random_detune() (
	(1 + (rand() - 0.5)*detuning_random_amount)*(rand() < detuning_random_halving ? 2 : 1);
);

function process_note(note*) local(env_semitones, timbre_semitones, timbre_shift_decay_samples) (
	synth_sample_each(note) ? (
		synth_needs_init(note) ? (
			note.WAVELENGTH_L = srate/synth_freq(note)*random_detune();
			note.INDEX_L = floor(rand()*note.WAVELENGTH_L);
			note.LFO_PHASE_L = rand();
			note.LFO_FREQ_DIFF_L = lr_detune_cents > 0 ? 0.9 + 0.2*rand() : 1;
			note.WAVELENGTH_R = lr_detune_cents > 0 ? srate/synth_freq(note)*random_detune() : note.WAVELENGTH_L;
			note.INDEX_R = lr_detune_cents > 0 ? floor(rand()*note.WAVELENGTH_R) : note.INDEX_L;
			note.LFO_PHASE_R = lr_detune_cents > 0 ? rand() : note.LFO_PHASE_L;
			note.LFO_FREQ_DIFF_R = lr_detune_cents > 0 ? 0.9 + 0.2*rand() : 1;
			timbre_semitones = timbre_shift_tracking*(synth_midinote(note) - 60) + timbre_shift_velocity_semitones*(synth_velocity(note) - 64)/64;
			note.TIMBRE_FACTOR = pow(2, timbre_semitones/12)*oversampling_factor;


			note.ENV_DECAY = 1;
			note.TIMBRE_DECAY = 1;

			timbre_shift_decay_samples = srate*timbre_shift_decay_ms*0.001;
			timbre_shift_decay_samples *= pow(2, timbre_shift_decay_velocity_log2*(synth_velocity(note) - 63.5)/63.5);
			note.TIMBRE_DECAY_FACTOR = exp(-1/timbre_shift_decay_samples);
		);

		amp = synth_velocity(note)/127;
		attack = synth_attack(note) - latency_samples;
		attack >= 0 ? (
			attack < attack_samples ? (
				amp *= attack/attack_samples;
			);
			release = synth_sustain_release(note) - latency_samples;
			release > 0 ? (
				release >= release_samples ? (
					synth_stop(note);
					amp = 0;
				) : (
					amp *= (1 - release/release_samples);
				);
			);
			note.ENV_DECAY *= env_decay_factor;
			amp = amp*(note.ENV_DECAY*(1 - env_sustain) + env_sustain);

			index_l = (note.INDEX_L += 1);
			wavelength_l = note.WAVELENGTH_L;
			index_l >= wavelength_l ? (
				while (index_l >= wavelength_l) (
					index_l -= wavelength_l;
				);
				vibrato_factor = vib_mode ? (
					phase = (attack/vib_lfo_wavelength_samples + note.LFO_PHASE_L)*note.LFO_FREQ_DIFF_L;
					1 + sin(phase*2*$pi)*vib_lfo_scale_factor*min(1, attack/vib_lfo_attack_samples);
				) : (
					vibrato_tracking ?
						pow(freq_factor, min(1, attack/(0.3*srate))*vibrato_tracking)
					: 1;
				);
				wavelength_l = note.WAVELENGTH_L = srate/synth_freq(note)*vibrato_factor*lr_detune_factor*random_detune();
				while (index_l >= wavelength_l) (
					index_l -= wavelength_l;
				);
				note.INDEX_L = index_l;
			);
			index_r = (note.INDEX_R += 1);
			wavelength_r = note.WAVELENGTH_R;
			index_r >= wavelength_r ? (
				while (index_r >= wavelength_r) (
					index_r -= wavelength_r;
				);
				vibrato_factor = vib_mode ? (
					phase = (attack/vib_lfo_wavelength_samples + note.LFO_PHASE_R)*note.LFO_FREQ_DIFF_R;
					1 + sin(phase*2*$pi)*vib_lfo_scale_factor*min(1, attack/vib_lfo_attack_samples);
				) : (
					vibrato_tracking ?
						pow(freq_factor, min(1, attack/(0.3*srate))*vibrato_tracking)
					: 1;
				);
				wavelength_r = note.WAVELENGTH_R = lr_detune_cents > 0 ? srate/synth_freq(note)*vibrato_factor/lr_detune_factor*random_detune() : note.WAVELENGTH_L;

				while (index_r >= wavelength_r) (
					index_r -= wavelength_r;
				);
				note.INDEX_R = index_r;
			);

			timbre_factor = timbre_shift_factor*note.TIMBRE_FACTOR;
			timbre_shift_sustain_semitones ? (
				note.TIMBRE_DECAY *= note.TIMBRE_DECAY_FACTOR;

				env_semitones = timbre_shift_sustain_semitones*(1 - note.TIMBRE_DECAY);
				timbre_factor *= pow(2, env_semitones/12);
			);

			// Left
			left = interp_sample(index_l, wavelength_l, kernelA0, kernelB0);
			right = interp_sample(index_r, wavelength_r, kernelA1_read, kernelB1_read);

			spl0 += left*amp;
			spl1 += right*amp;
		);
	);
	synth_continue(note);
);
process_note(synth1)
&& process_note(synth2)
&& process_note(synth3)
&& process_note(synth4)
&& process_note(synth5)
&& process_note(synth6)
&& process_note(synth7)
&& process_note(synth8)
&& process_note(synth9)
&& process_note(synth10)
&& process_note(synth11)
&& process_note(synth12)
&& process_note(synth13)
&& process_note(synth14)
&& process_note(synth15)
&& process_note(synth16);

spl0 = filter_buffer_sample(filter_left, spl0);
spl1 = filter_buffer_sample(filter_right, spl1);

splm = (spl0 + spl1)*0.5;
spls = (spl0 - spl1)*0.5*smoother_value(stereo_width);

spl0 = splm + spls;
spl1 = splm - spls;

@gfx 674 444

function labelled_dial(value, low, high, bias, label, number_format, default) local(h) (
	h = min(50, ui_height()*0.5);
	ui_push_height(h);
		value = control_dial(value, low, high, bias, default);
	ui_pop();
	ui_push_above(h);
		ui_align(0.5, 0.85);
		ui_text(label);
	ui_pop();
	ui_push_below(h);
		ui_align(0.5, 0.15);
		number_format >= 0 ? (
			ui_textnumber(value*1.000001, number_format);
		);
	ui_pop();
	value;
);

function labelled_switch(value, label, text) local(h) (
	h = min(50, ui_height()*0.5);
	ui_push_height(min(30, h));
		ui_push_width(60);
			value = control_switch(value);
		ui_pop();
	ui_pop();
	ui_push_above(h);
		ui_align(0.5, 0.85);
		ui_text(label);
	ui_pop();
	ui_push_below(h);
		ui_align(0.5, 0.15);
		ui_text(text);
	ui_pop();
	value;
);
control_start("main", "default");

ui_screen() == "main" ? (
	control_navbar("Humonica", "config", "synth.config");

	ui_split_bottom(min(ui_height()*0.1, 50));
		control_background_technical();
		ui_graph(kernelA0[1] !== 0 ? kernelA0 : kernelA1, window_samples, -window_samples*0.5, kernel_length, 0.00000001, 0.00000001);
		control_finish_technical();
	ui_pop();

	ui_split_topratio(1/3);
		ui_split_leftratio(1/7);
			waveform_mode = labelled_switch(waveform_mode, "Mode", waveform_mode ? "audio" : "fixed");
		ui_pop();

		waveform_mode ? (
			ui_split_leftratio(4/6);
				control_group("Analysis");
				ui_split_leftratio(1/4);
					window_ms = labelled_dial(window_ms, 5, 150, 1.5, "Window", "%ims", 30);
				ui_split_next();
					crossover_ratio = labelled_dial(crossover_ratio, 1, 10, 3, "Overlap", "x%.2f", 1.25);
				ui_split_next();
					latency_switch = labelled_switch(latency_switch, "Latency", latency_switch ? "compensated" : "zero (live)");
				ui_split_next();
					stereo_switch = labelled_switch(stereo_switch, "Stereo", stereo_switch ? "separate" : "joined");
				ui_pop();
			ui_pop();

			control_group("Volume");
			ui_split_leftratio(1/2);
				ui_automate(volume_target_db, labelled_dial(volume_target_db, -24, 0, 0, "Target", "%.1fdB", -12));
			ui_split_next();
				ui_automate(volume_max_gain_db, labelled_dial(volume_max_gain_db, 0, 48, 0, "Max Boost", "%.1fdB", 24));
			ui_pop();
		) : (
			ui_split_rightratio(1/7);
				ui_automate(volume_target_db, labelled_dial(volume_target_db, -24, 0, 0, "Volume", "%.1fdB", -12));
				ui_press() || ui_drag() ? (
					spectrum_kernel_is_up_to_date = 0;
				);
			ui_pop();

			ui_fontsize(12);
			ui_split_righttext("Sample audio");
				ui_split_topratio(1/3);
					control_button("Sample audio") ? action_sample_audio = 1;
				ui_split_next();
					control_button("Reset 1") ? action_reset_spectrum = 1;
				ui_split_next();
					control_button("Reset 2") ? action_reset_spectrum = 2;
				ui_pop();
			ui_pop();

			control_background_technical();

			g_graph.graph_range_x(20, 20000);
			g_graph.graph_range_y(spectrum_min_db, 0);

			// Specialised versions
			g_graph.graph_grid_color(255, 255, 255, 0.6);
			g_graph.graph_grid_x_logfreq();
			g_graph.graph_grid_color(255, 255, 255, 0.4);
			g_graph.graph_grid_y(0, 6, "%idB");

			ui_graph(spectrum_db, spectrum_N, spectrum_min_db, 0);
			graph_edit(spectrum_db, spectrum_N, spectrum_min_db, 0);
			control_finish_technical();
			ui_mouse_up() ? (
				uix_undo_point(1);
			);

			ui_press() || ui_drag() || ui_mouse_up() ? (
				spectrum_kernel_is_up_to_date = 0;
			);
		);
	ui_split_next();
		ui_split_leftratio(2/9);
			control_group("Stereo");
			ui_split_leftratio(1/2);
				ui_automate(lr_detune_cents, labelled_dial(lr_detune_cents, 0, 100, 4, "Detune", lr_detune_cents < 2 ? "%.1f cents" : "%i cents", 3));
			ui_split_next();
				ui_automate(stereo_width, labelled_dial(stereo_width, 0, 1, 0, "Width", "", 0.5));
			ui_pop();
		ui_pop();

		ui_split_leftratio(4/7);
			control_group("Timbre");
			ui_split_leftratio(1/4);
				ui_automate(timbre_shift_semitones, labelled_dial(timbre_shift_semitones, -12, 12, 0, "Shift", "%.1f st", 0));
			ui_split_next();
				ui_automate(timbre_shift_tracking, labelled_dial(timbre_shift_tracking, -0.5, 0.5, 0, "Pitch", "", 0));
			ui_split_next();
				ui_automate(timbre_shift_velocity_semitones, labelled_dial(timbre_shift_velocity_semitones, -12, 12, 0, "Velocity", "Velocity", 0));
			ui_split_next();
				ui_automate(lowpass_freq_khz, labelled_dial(lowpass_freq_khz, 1, 20, 2, "Filter", "%.f kHz", 8));
			ui_pop();
		ui_pop();

		ui_split_leftratio(3/3);
			control_group("Sweep");
			ui_split_leftratio(1/3);
				ui_automate(timbre_shift_sustain_semitones, labelled_dial(timbre_shift_sustain_semitones, -48, 12, -2.8, "Sweep", "%.1f st", 0));
			ui_split_next();
				ui_automate(timbre_shift_decay_ms, labelled_dial(timbre_shift_decay_ms, 1, 2000, 4, "Speed", timbre_shift_decay_ms < 5 ? "%.1fms" : "%ims", 150));
			ui_split_next();
				ui_automate(timbre_shift_decay_velocity_log2, labelled_dial(timbre_shift_decay_velocity_log2, -2, 2, 0, "Velocity", "", 0));
			ui_pop();
		ui_pop();
	ui_split_next();
		ui_split_leftratio(3/9);
			control_group("Vibrato");
			ui_split_leftratio(1/3);
				/*
				waveform_mode ? (
					vib_mode = labelled_switch(vib_mode, "Vibrato", vib_mode ? "LFO" : "tracking");
				) : (
					ui_text("LFO");
				);
			ui_split_next();
			*/
				vib_mode ? (
					ui_automate(vib_lfo_scale_cents, labelled_dial(vib_lfo_scale_cents, 0, 100, 4, "Depth", "%i cents", 5));
				) : (
					vibrato_tracking = max(0, labelled_dial(vibrato_tracking, -0.001, 1, 0, "Tracking", "strength", 0));
				);
			ui_split_next();
				vib_mode ? (
					ui_automate(vib_lfo_hz, labelled_dial(vib_lfo_hz, 0.5, 10, 3, "Freq", "%.1f Hz", 4.7));
				) : (
					tonality_limit = labelled_dial(tonality_limit, 0, 0.5, 0, "Tonality", "limit", 0);
				);
			ui_split_next();
				vib_mode ? (
					vib_lfo_attack_ms = labelled_dial(vib_lfo_attack_ms, 1, 2000, 4, "Attack", "%ims", 350);
				) : (
					0;
				);
			ui_pop();
		ui_pop();

		ui_split_leftratio(4/6);
			control_group("Envelope");
			ui_split_leftratio(1/4);
				attack_ms = labelled_dial(attack_ms, 0, 1000, 5, "Attack", "%ims", 5);
			ui_split_next();
				env_decay_ms = labelled_dial(env_decay_ms, 0, 2000, 5, "Decay", "%ims", 300);
			ui_split_next();
				env_sustain = labelled_dial(env_sustain, 0, 1, 1, "Sustain", "", 1);
			ui_split_next();
				release_ms = labelled_dial(release_ms, 0, 2000, 5, "Release", "%ims", 10);
			ui_pop();
		ui_pop();

		ui_split_leftratio(2/2);
			control_group("Texture");
			ui_split_leftratio(1/2);
				ui_automate(detuning_random_amount, labelled_dial(detuning_random_amount, 0, 0.1, 2, "Growl", "", 0));
			ui_split_next();
				ui_automate(detuning_random_halving, labelled_dial(detuning_random_halving, 0, 0.5, 2, "Grit", "", 0));
			ui_pop();
		ui_pop();
	ui_pop();

) : ui_screen() == "help" ? (
	control_navbar("Humonica - Help", -1, -1);

	ui_align(0, 0);
	ui_wraptext("Window: controls how much input audio is used to calculate the impulse for resynthesis.  Lower values give a faster-changing sound (better time-resolution), but reduced frequency resolution.\n\nOverlap: controls how often the impulse is recalculated, as a function of the window length.  Higher values mean recalculating more often, which gives a smoother result, at the expense of more calculation.\n\nLatency: the impulse is calculated using input audio. This switch chooses between zero-latency (\"live\") mode, where the analysis will always be slightly behind the input audio (depending on window length and overlap amount) or whether some extra latency is added to compensate.\n\nStereo: the left and right inputs can either be combined (their energy is added together) or calculated separately. 1-channel mode is slightly more efficient, so should be used unless you particularly need separate stereo channels.");
) : synth_ui_system() || ui_system();

@serialize

preset_version = 8;
file_var(0, preset_version);

synth_serialize(preset_version < 3);

preset_version < 4 ? (
	timbre_shift_sustain_semitones = 0;
	timbre_shift_decay_ms = 150;
	timbre_shift_velocity_semitones = 0;
	env_sustain = 1;
	env_decay_ms = 300;
);
preset_version < 5 ? (
	waveform_mode = 1;
	reset_spectrum(300);

	volume_target_db = -12;
	volume_max_gain_db = 0;
) : (
	file_var(0, spectrum_low_freq);
	file_var(0, spectrum_high_freq);
	file_var(0, spectrum_min_db);
	file_var(0, spectrum_N);
	s_i = 0;
	while (s_i < spectrum_N) (
		file_var(0, spectrum_db[s_i]);
		s_i += 1;
	);
);
preset_version < 6 ? (
	detuning_random_amount = 0;
);
preset_version < 7 ? (
	detuning_random_halving = 0;
);
preset_version < 8 ? (
	timbre_shift_decay_velocity_log2 = 0;
);

spectrum_kernel_is_up_to_date = 0;
